<?xml version="1.0"?>
<article xmlns:r="http://www.r-project.org"
         xmlns:xi="http://www.w3.org/2003/XInclude">

<articleinfo>

<title></title>

<author><firstname>Duncan</firstname><surname>Temple Lang</surname>
  <affiliation><orgname>University of California at Davis</orgname>
               <orgdiv>Department of Statistics</orgdiv>
  </affiliation>
</author>
</articleinfo>

<section>
<title></title>

<para>
This is an example of how we can do relatively simple annotation
of plots with the existing FlashMXML device (as of Feb 4, 2010).
I have made some relatively easy changes that allow us to do this.
To annotate one or more elements of a plot, we need to arrange to
augment the code for the appropriate elements before it is written to a file.
(Once it is written to a file, we will have more trouble recovering it
as we have lost information about which lines of code  correspond to which element
of a plot. We will have to parse the ActionScript code which we don't want to do.) 
We can specify a function that is called when the device is being
closed. This is responsible for generating the file.
It is at this point that we can post-process or annotate the code generated
by the device as the plot(s) were being drawn.
This <r:arg>wrapup</r:arg> function is called with an object of 
class <r:class>FlashObjectsPlotsCode</r:class> (which is a list)
with an element for each "page" generated by the device.
We can process each element and find the elements within each plot.
We can then augment the code and return the updated page 
and the use the regular wrapup code, i.e. mxmlWrapup.
</para>
<para>
To annotate the elements, we first have to break the code into
lines corresponding to each element,
i.e. circle, line, text, etc.
This is (currently) done by the function <r:func>groupCommands</r:func>.
</para>
<para>
So let's look at an example.
We start by loading the <r:pkg>FlashMXML</r:pkg> package:
<r:code>
library(FlashMXML)
</r:code>

We define a function that takes a given "page" of 
ActionScript code and breaks the lines of code into 
code for each graphical element in the plot
and then annotates it. 
The annotation adds code  to set the name of the object
and also to add two event handlers.
We'll do this with a function <r:func>addPointNames</r:func>.
This only annotates circles. We'll make this more intelligent
later.
<r:code>
addPointNames = 
function(page)  {
  els = FlashMXML:::groupCommands(page)
  i = (names(els) == "circle")
  els[i] = mapply(function(x, id) {
                    c(x[-length(x)], 
                      sprintf('tmp.name = "%d"', id), 
                      "tmp.buttonMode = true;",
                      "tmp.addEventListener(MouseEvent.MOUSE_OVER, highlight);",
                      "tmp.addEventListener(MouseEvent.MOUSE_OUT, unhighlight);",
                     "")
                  },
                  els[i], seq(along = els[i]), SIMPLIFY = FALSE)
  unlist(els)
}
</r:code>

Now we are ready to create our device and create a plot.
We specify a different function for the <r:arg>wrapup</r:arg> which
takes  the code for each and the name of the file(s).
Our <r:arg>wrapup</r:arg> function annotates each of the pages and then
invokes the regular function to write the code to a file, i.e.
create the MXML file.
Our <r:arg>wrapup</r:arg> function will get called when the 
device is being closed, i.e. in the call to <r:func>dev.off</r:func>
<r:code>
dev = mxmlDevice("/tmp/foo.mxml", compile = FALSE, 
                 wrapup = function(pages, files, fonts, ...) {
                     k = class(pages)
                     new.pages = lapply(pages, addPointNames)
                     writeCode(new(class, new.pages), files, fonts = fonts, ...)
                  })
</r:code>
So now we create our plot and then turn the device off:
<r:code>
plot(1:10)
dev.off()
</r:code>
The resulting file /tmp/foo.mxml then contains our annotated ActionScript code.
</para>
<para>
Of course, the annotation function we use will depend on the nature of
the plot.  In the longer term, we will probably represent the "page"
as structured objects identifying the elements.  This will be a
general, device independent description and then we will have coercion
methods to create the ActionScript, MXML, JavaScript, SVG code.
</para>

</section>
</article>